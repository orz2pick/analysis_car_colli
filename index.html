<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>YOLOv8 驾驶实时分析系统</title>
    <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web@1.16.3/dist/ort.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; touch-action: none; }
        body { 
            background: #0a0a0a; 
            color: #fff; 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, monospace;
            overflow: hidden;
            height: 100vh;
        }

        #app { display: flex; flex-direction: column; height: 100%; }

        /* 顶部统计面板 */
        #stats-panel {
            height: 70px;
            background: linear-gradient(180deg, #1a1a1a 0%, #0f0f0f 100%);
            border-bottom: 1px solid #333;
            display: flex;
            align-items: center;
            padding: 0 15px;
            gap: 20px;
            font-size: 13px;
            overflow-x: auto;
            white-space: nowrap;
        }
        .stat-box { 
            background: rgba(255,255,255,0.05); 
            padding: 8px 12px; 
            border-radius: 6px; 
            border: 1px solid #333;
            min-width: 80px;
        }
        .stat-label { color: #666; font-size: 11px; margin-bottom: 2px; }
        .stat-value { color: #0f0; font-weight: bold; font-size: 14px; }
        .stat-value.danger { color: #f33; }
        .stat-value.warning { color: #fa0; }

        /* 主视频区 */
        #video-container {
            flex: 1;
            position: relative;
            background: #000;
            overflow: hidden;
        }
        #mainCanvas {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            object-fit: contain;
        }
        #sourceVideo {
            position: absolute;
            opacity: 0;
            pointer-events: none;
        }

        /* 预处理可视化（画中画） */
        #preprocess-view {
            position: absolute;
            top: 15px; right: 15px;
            width: 200px; height: 150px;
            background: rgba(0,0,0,0.9);
            border: 2px solid #0f0;
            border-radius: 8px;
            overflow: hidden;
            display: none;
            box-shadow: 0 4px 20px rgba(0,0,0,0.8);
        }
        #preprocess-view.active { display: block; }
        #preprocessCanvas { width: 100%; height: 100%; }
        #preprocess-label {
            position: absolute;
            bottom: 0; left: 0; right: 0;
            background: rgba(0,255,0,0.2);
            color: #0f0;
            font-size: 10px;
            padding: 4px;
            text-align: center;
            border-top: 1px solid #0f0;
        }

        /* 控制栏 */
        #controls {
            height: 160px;
            background: #141414;
            border-top: 1px solid #333;
            padding: 12px 15px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        /* 时间轴 */
        #timeline-wrapper {
            position: relative;
            height: 50px;
            background: #222;
            border-radius: 8px;
            overflow: hidden;
            cursor: pointer;
        }
        #timelineCanvas { width: 100%; height: 100%; }
        #playhead {
            position: absolute;
            top: 0; width: 3px; height: 100%;
            background: #fff;
            box-shadow: 0 0 10px rgba(255,255,255,0.8);
            pointer-events: none;
            transition: left 0.1s linear;
        }

        /* 按钮组 */
        .btn-group {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        .btn {
            background: #007aff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }
        .btn:active { transform: scale(0.95); opacity: 0.8; }
        .btn:disabled { background: #333; color: #666; cursor: not-allowed; }
        .btn.toggle { background: #333; border: 1px solid #555; }
        .btn.toggle.active { background: #0f0; color: #000; border-color: #0f0; }

        input[type="file"] { display: none; }

        .center-msg {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #666;
        }
        .loading-spinner {
            width: 40px; height: 40px;
            border: 3px solid #333;
            border-top-color: #0f0;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }
        @keyframes spin { to { transform: rotate(360deg); } }

        /* 警告遮罩 */
        #danger-overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            border: 8px solid transparent;
            pointer-events: none;
            transition: all 0.2s;
        }
        #danger-overlay.active {
            border-color: rgba(255,50,50,0.8);
            background: radial-gradient(circle, transparent 50%, rgba(255,0,0,0.2) 100%);
            box-shadow: inset 0 0 50px rgba(255,0,0,0.5);
        }
    </style>
</head>
<body>

<div id="app">
    <!-- 统计面板 -->
    <div id="stats-panel">
        <div class="stat-box">
            <div class="stat-label">推理耗时</div>
            <div class="stat-value" id="perf-inference">-- ms</div>
        </div>
        <div class="stat-box">
            <div class="stat-label">预处理</div>
            <div class="stat-value" id="perf-preproc">-- ms</div>
        </div>
        <div class="stat-box">
            <div class="stat-label">FPS</div>
            <div class="stat-value" id="perf-fps">--</div>
        </div>
        <div class="stat-box">
            <div class="stat-label">检测车辆</div>
            <div class="stat-value" id="perf-objects">0</div>
        </div>
        <div class="stat-box">
            <div class="stat-label">TTC(最近)</div>
            <div class="stat-value" id="perf-ttc">--</div>
        </div>
        <div style="flex:1"></div>
        <div class="stat-box" style="border-color:#444">
            <div class="stat-label">状态</div>
            <div style="color:#888; font-size:12px;" id="status-text">初始化...</div>
        </div>
    </div>

    <!-- 视频区 -->
    <div id="video-container">
        <video id="sourceVideo" playsinline muted></video>
        <canvas id="mainCanvas"></canvas>
        
        <!-- 危险警告遮罩 -->
        <div id="danger-overlay"></div>

        <!-- 预处理可视化 -->
        <div id="preprocess-view">
            <canvas id="preprocessCanvas"></canvas>
            <div id="preprocess-label">YOLO 输入 (640×640)</div>
        </div>

        <div class="center-msg" id="upload-msg">
            <div class="loading-spinner" style="display:none" id="loading"></div>
            <div style="font-size:18px; margin-bottom:10px;" id="msg-text">请选择行车记录仪视频</div>
            <label class="btn" for="fileInput">上传视频开始分析</label>
            <input type="file" id="fileInput" accept="video/*">
        </div>
    </div>

    <!-- 控制栏 -->
    <div id="controls">
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;">
            <span style="color:#888; font-size:12px;">时间轴（绿色=安全，黄色=注意，红色=危险）</span>
            <span style="color:#666; font-size:11px;" id="time-display">00:00 / 00:00</span>
        </div>
        
        <div id="timeline-wrapper">
            <canvas id="timelineCanvas"></canvas>
            <div id="playhead" style="left:0%"></div>
        </div>

        <div class="btn-group">
            <button class="btn" id="playBtn" disabled>▶ 播放</button>
            <button class="btn toggle" id="togglePreprocess">显示预处理</button>
            <button class="btn toggle" id="toggleEnhance">图像增强</button>
            <div style="flex:1"></div>
            <span style="color:#666; font-size:12px;">YOLOv8n • 每帧分析</span>
        </div>
    </div>
</div>

<script>
/**
 * YOLOv8 驾驶分析系统 - 使用 GitHub 托管模型
 */

// ================= 配置 =================
const CONFIG = {
    // 使用 Raw GitHub URL 获取模型文件
    MODEL_URL: 'https://raw.githubusercontent.com/orz2pick/analysis_car_colli/main/yolov8n.onnx',
    INPUT_SIZE: 640,
    CONF_THRESH: 0.45,
    IOU_THRESH: 0.45,
    CLASSES: {
        2: 'car', 3: 'motorcycle', 5: 'bus', 7: 'truck'
    },
    TTC_THRESHOLD_DANGER: 1.5,
    TTC_THRESHOLD_WARNING: 3.5,
    ENABLE_ENHANCE: false
};

// ================= 全局状态 =================
let session = null;
let isRunning = false;
let isPaused = false;
let frameId = null;
let stats = {
    inferenceTime: 0,
    prepTime: 0,
    lastTime: performance.now(),
    frameCount: 0,
    fps: 0
};
let trackHistory = [];
let modelInputName = 'images'; // 默认输入名，会在加载时自动检测
let modelOutputName = 'output0'; // 默认输出名

// DOM 元素
const video = document.getElementById('sourceVideo');
const mainCanvas = document.getElementById('mainCanvas');
const mainCtx = mainCanvas.getContext('2d');
const pCanvas = document.getElementById('preprocessCanvas');
const pCtx = pCanvas.getContext('2d');
const timelineCanvas = document.getElementById('timelineCanvas');
const tCtx = timelineCanvas.getContext('2d');

// ================= 初始化 =================
async function init() {
    updateStatus('从 GitHub 加载 YOLOv8 模型...', true);
    
    try {
        session = await ort.InferenceSession.create(CONFIG.MODEL_URL, {
            executionProviders: ['webgl'],
            graphOptimizationLevel: 'all'
        });
        
        // 自动检测输入输出节点名称
        const inputNames = session.inputNames;
        const outputNames = session.outputNames;
        
        if (inputNames.length > 0) modelInputName = inputNames[0];
        if (outputNames.length > 0) modelOutputName = outputNames[0];
        
        console.log('Model loaded:', { input: modelInputName, output: modelOutputName });
        updateStatus(`模型就绪 (${inputNames.length}输入/${outputNames.length}输出)`);
        document.getElementById('msg-text').textContent = '模型加载完成，请选择视频';
        document.getElementById('loading').style.display = 'none';
    } catch (e) {
        console.error(e);
        updateStatus('模型加载失败: ' + e.message);
        alert('无法从 GitHub 加载模型，请检查网络连接是否能访问 raw.githubusercontent.com');
    }
}

// ================= 图像预处理 =================
function preprocess(sourceCanvas) {
    const start = performance.now();
    const size = CONFIG.INPUT_SIZE;
    
    const letterboxCanvas = document.createElement('canvas');
    letterboxCanvas.width = size;
    letterboxCanvas.height = size;
    const lbCtx = letterboxCanvas.getContext('2d');
    
    const scale = Math.min(size / sourceCanvas.width, size / sourceCanvas.height);
    const newW = Math.round(sourceCanvas.width * scale);
    const newH = Math.round(sourceCanvas.height * scale);
    const padX = Math.floor((size - newW) / 2);
    const padY = Math.floor((size - newH) / 2);
    
    // 灰色填充
    lbCtx.fillStyle = '#808080';
    lbCtx.fillRect(0, 0, size, size);
    
    // 可选增强
    if (CONFIG.ENABLE_ENHANCE) {
        lbCtx.filter = 'contrast(1.2) brightness(1.1)';
    }
    
    lbCtx.drawImage(sourceCanvas, 0, 0, sourceCanvas.width, sourceCanvas.height, padX, padY, newW, newH);
    lbCtx.filter = 'none';
    
    // 可视化
    if (document.getElementById('preprocess-view').classList.contains('active')) {
        pCanvas.width = size;
        pCanvas.height = size;
        pCtx.drawImage(letterboxCanvas, 0, 0);
        pCtx.strokeStyle = 'rgba(0,255,0,0.3)';
        pCtx.lineWidth = 1;
        for (let i = 0; i < size; i += 64) {
            pCtx.beginPath(); pCtx.moveTo(i, 0); pCtx.lineTo(i, size); pCtx.stroke();
            pCtx.beginPath(); pCtx.moveTo(0, i); pCtx.lineTo(size, i); pCtx.stroke();
        }
    }
    
    // 提取像素 -> CHW Float32
    const imageData = lbCtx.getImageData(0, 0, size, size);
    const data = imageData.data;
    const tensor = new Float32Array(3 * size * size);
    
    for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
            const idx = (y * size + x) * 4;
            tensor[0 * size * size + y * size + x] = data[idx] / 255.0;     // R
            tensor[1 * size * size + y * size + x] = data[idx + 1] / 255.0; // G
            tensor[2 * size * size + y * size + x] = data[idx + 2] / 255.0; // B
        }
    }
    
    stats.prepTime = performance.now() - start;
    
    return {
        tensor: new ort.Tensor('float32', tensor, [1, 3, size, size]),
        scale: scale,
        padX: padX,
        padY: padY,
        origW: sourceCanvas.width,
        origH: sourceCanvas.height
    };
}

// ================= 后处理 =================
function postprocess(outputTensor, prepInfo) {
    const { scale, padX, padY, origW, origH } = prepInfo;
    const data = outputTensor.data;
    const dims = outputTensor.dims;
    
    const numClasses = 80;
    const numBoxes = dims[2];
    const boxes = [];
    
    for (let i = 0; i < numBoxes; i++) {
        const offset = i * 84; // 4 coords + 80 classes
        const cx = data[offset];
        const cy = data[offset + 1];
        const w = data[offset + 2];
        const h = data[offset + 3];
        
        let maxScore = 0;
        let classId = 0;
        for (let c = 0; c < numClasses; c++) {
            const score = data[offset + 4 + c];
            if (score > maxScore) {
                maxScore = score;
                classId = c;
            }
        }
        
        if (maxScore < CONFIG.CONF_THRESH || !CONFIG.CLASSES[classId]) continue;
        
        const x1 = (cx - w/2 - padX) / scale;
        const y1 = (cy - h/2 - padY) / scale;
        const x2 = (cx + w/2 - padX) / scale;
        const y2 = (cy + h/2 - padY) / scale;
        
        boxes.push({
            x1: Math.max(0, Math.min(origW, x1)),
            y1: Math.max(0, Math.min(origH, y1)),
            x2: Math.max(0, Math.min(origW, x2)),
            y2: Math.max(0, Math.min(origH, y2)),
            score: maxScore,
            class: CONFIG.CLASSES[classId],
            cx: (x1 + x2) / 2,
            cy: (y1 + y2) / 2,
            w: x2 - x1,
            h: y2 - y1
        });
    }
    
    // NMS
    boxes.sort((a, b) => b.score - a.score);
    const kept = [];
    const suppressed = new Set();
    
    for (let i = 0; i < boxes.length; i++) {
        if (suppressed.has(i)) continue;
        const current = boxes[i];
        kept.push(current);
        
        for (let j = i + 1; j < boxes.length; j++) {
            if (suppressed.has(j)) continue;
            if (calculateIoU(current, boxes[j]) > CONFIG.IOU_THRESH) {
                suppressed.add(j);
            }
        }
    }
    
    return kept;
}

function calculateIoU(a, b) {
    const interX1 = Math.max(a.x1, b.x1);
    const interY1 = Math.max(a.y1, b.y1);
    const interX2 = Math.min(a.x2, b.x2);
    const interY2 = Math.min(a.y2, b.y2);
    const interArea = Math.max(0, interX2 - interX1) * Math.max(0, interY2 - interY1);
    const areaA = (a.x2 - a.x1) * (a.y2 - a.y1);
    const areaB = (b.x2 - b.x1) * (b.y2 - b.y1);
    return interArea / (areaA + areaB - interArea + 1e-6);
}

// ================= TTC 计算 =================
function calculateTTC(detections, videoTime) {
    const centerX = mainCanvas.width / 2;
    const laneWidth = mainCanvas.width * 0.4;
    
    const centerCars = detections.filter(d => 
        Math.abs(d.cx - centerX) < laneWidth && d.cy > mainCanvas.height * 0.3
    ).sort((a, b) => b.cy - a.cy);
    
    if (centerCars.length === 0) return { ttc: Infinity, target: null };
    
    const target = centerCars[0];
    const currentY = target.cy;
    const history = trackHistory.filter(h => 
        Math.abs(h.x - target.cx) < target.w * 0.5 && videoTime - h.time < 1.0
    );
    
    let ttc = Infinity;
    
    if (history.length >= 2) {
        const dt = videoTime - history[0].time;
        const dy = currentY - history[0].y;
        const velocity = dy / dt;
        if (velocity > 5) {
            const hoodY = mainCanvas.height * 0.9;
            const remainingDist = hoodY - currentY;
            ttc = remainingDist / velocity;
        }
    }
    
    if (ttc === Infinity && history.length === 0) {
        ttc = Math.max(0.5, (target.h / 50) * 3);
    }
    
    trackHistory.push({ x: target.cx, y: currentY, time: videoTime, h: target.h });
    trackHistory = trackHistory.filter(h => videoTime - h.time < 2.0);
    
    return { ttc, target };
}

// ================= 主循环 =================
async function processFrame() {
    if (!isRunning) return;
    
    if (isPaused) {
        frameId = requestAnimationFrame(processFrame);
        return;
    }
    
    if (video.ended) {
        isRunning = false;
        updateStatus('分析完成');
        document.getElementById('playBtn').textContent = '▶ 播放';
        return;
    }
    
    const loopStart = performance.now();
    
    if (mainCanvas.width !== video.videoWidth || mainCanvas.height !== video.videoHeight) {
        mainCanvas.width = video.videoWidth;
        mainCanvas.height = video.videoHeight;
    }
    mainCtx.drawImage(video, 0, 0);
    
    const prep = preprocess(mainCanvas);
    
    const inferStart = performance.now();
    const feeds = {};
    feeds[modelInputName] = prep.tensor;
    const results = await session.run(feeds);
    stats.inferenceTime = performance.now() - inferStart;
    
    const detections = postprocess(results[modelOutputName], prep);
    const { ttc, target } = calculateTTC(detections, video.currentTime);
    
    mainCtx.clearRect(0, 0, mainCanvas.width, mainCanvas.height);
    mainCtx.drawImage(video, 0, 0);
    
    let isDanger = false;
    
    detections.forEach((d, i) => {
        const isTarget = target && Math.abs(d.cx - target.cx) < d.w * 0.5;
        let color = isTarget ? '#0f0' : '#666';
        let lineWidth = 2;
        
        if (isTarget) {
            if (ttc < CONFIG.TTC_THRESHOLD_DANGER) {
                color = '#ff0000';
                lineWidth = 4;
                isDanger = true;
            } else if (ttc < CONFIG.TTC_THRESHOLD_WARNING) {
                color = '#ffaa00';
                lineWidth = 3;
            }
        }
        
        mainCtx.strokeStyle = color;
        mainCtx.lineWidth = lineWidth;
        mainCtx.strokeRect(d.x1, d.y1, d.w, d.h);
        
        mainCtx.fillStyle = color;
        mainCtx.beginPath();
        mainCtx.arc(d.cx, d.cy, 4, 0, Math.PI*2);
        mainCtx.fill();
        
        mainCtx.font = `bold ${isTarget ? 18 : 14}px Arial`;
        const label = isTarget ? `${d.class} ${ttc.toFixed(1)}s` : d.class;
        mainCtx.fillText(label, d.x1, d.y1 - 8);
        mainCtx.fillText(`${(d.score*100).toFixed(0)}%`, d.x1, d.y1 + d.h + 15);
    });
    
    const dangerOverlay = document.getElementById('danger-overlay');
    if (isDanger) dangerOverlay.classList.add('active');
    else dangerOverlay.classList.remove('active');
    
    updateTimeline(video.currentTime, video.duration, ttc);
    updateStats(detections.length, ttc);
    
    stats.frameCount++;
    const now = performance.now();
    if (now - stats.lastTime > 1000) {
        stats.fps = Math.round(stats.frameCount * 1000 / (now - stats.lastTime));
        stats.frameCount = 0;
        stats.lastTime = now;
    }
    
    frameId = requestAnimationFrame(processFrame);
}

// ================= UI 函数 =================
function updateStats(objCount, ttc) {
    document.getElementById('perf-inference').textContent = stats.inferenceTime.toFixed(1) + ' ms';
    document.getElementById('perf-preproc').textContent = stats.prepTime.toFixed(1) + ' ms';
    document.getElementById('perf-fps').textContent = stats.fps;
    document.getElementById('perf-objects').textContent = objCount;
    
    const ttcEl = document.getElementById('perf-ttc');
    if (ttc === Infinity) {
        ttcEl.textContent = '--';
        ttcEl.className = 'stat-value';
    } else {
        ttcEl.textContent = ttc.toFixed(2) + 's';
        if (ttc < CONFIG.TTC_THRESHOLD_DANGER) ttcEl.className = 'stat-value danger';
        else if (ttc < CONFIG.TTC_THRESHOLD_WARNING) ttcEl.className = 'stat-value warning';
        else ttcEl.className = 'stat-value';
    }
}

function updateStatus(msg, loading = false) {
    document.getElementById('status-text').textContent = msg;
    document.getElementById('loading').style.display = loading ? 'block' : 'none';
}

function updateTimeline(current, duration, ttc) {
    if (!duration) return;
    const ratio = current / duration;
    const width = timelineCanvas.width;
    const height = timelineCanvas.height;
    const x = ratio * width;
    
    let color = '#00ff00';
    if (ttc < CONFIG.TTC_THRESHOLD_DANGER) color = '#ff0000';
    else if (ttc < CONFIG.TTC_THRESHOLD_WARNING) color = '#ffaa00';
    else if (ttc === Infinity) color = '#333';
    
    tCtx.fillStyle = color;
    tCtx.fillRect(x, 0, 2, height);
    
    document.getElementById('playhead').style.left = (ratio * 100) + '%';
    document.getElementById('time-display').textContent = 
        formatTime(current) + ' / ' + formatTime(duration);
}

function formatTime(s) {
    if (!s) return '00:00';
    const m = Math.floor(s / 60);
    const sec = Math.floor(s % 60);
    return `${m.toString().padStart(2,'0')}:${sec.toString().padStart(2,'0')}`;
}

// ================= 事件监听 =================
document.getElementById('fileInput').addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (!file) return;
    
    const url = URL.createObjectURL(file);
    video.src = url;
    video.onloadedmetadata = () => {
        document.getElementById('upload-msg').style.display = 'none';
        timelineCanvas.width = timelineCanvas.offsetWidth;
        timelineCanvas.height = timelineCanvas.offsetHeight;
        tCtx.clearRect(0, 0, timelineCanvas.width, timelineCanvas.height);
        
        video.play();
        isRunning = true;
        isPaused = false;
        trackHistory = [];
        document.getElementById('playBtn').disabled = false;
        document.getElementById('playBtn').textContent = '⏸ 暂停';
        updateStatus('分析中...');
        
        if (frameId) cancelAnimationFrame(frameId);
        processFrame();
    };
});

document.getElementById('playBtn').addEventListener('click', () => {
    if (isPaused) {
        video.play();
        isPaused = false;
        document.getElementById('playBtn').textContent = '⏸ 暂停';
    } else {
        video.pause();
        isPaused = true;
        document.getElementById('playBtn').textContent = '▶ 播放';
    }
});

document.getElementById('togglePreprocess').addEventListener('click', function() {
    document.getElementById('preprocess-view').classList.toggle('active');
    this.classList.toggle('active');
});

document.getElementById('toggleEnhance').addEventListener('click', function() {
    CONFIG.ENABLE_ENHANCE = !CONFIG.ENABLE_ENHANCE;
    this.classList.toggle('active');
    updateStatus(CONFIG.ENABLE_ENHANCE ? '图像增强已开启' : '图像增强已关闭');
});

document.getElementById('timeline-wrapper').addEventListener('click', (e) => {
    if (!video.duration) return;
    const rect = e.currentTarget.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const ratio = x / rect.width;
    video.currentTime = ratio * video.duration;
});

window.addEventListener('resize', () => {
    if (timelineCanvas) {
        timelineCanvas.width = timelineCanvas.offsetWidth;
        timelineCanvas.height = timelineCanvas.offsetHeight;
    }
});

// 启动
init();
</script>
</body>
</html>
