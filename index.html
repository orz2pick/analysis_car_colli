<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI 驾驶行为分析 - 视频版</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@latest"></script>
    <style>
        :root { --danger: #ff4d4d; --safe: #2ecc71; }
        body { margin: 0; background: #121212; color: white; font-family: system-ui; display: flex; flex-direction: column; height: 100vh; }
        
        /* 视频显示区 */
        #stage { position: relative; flex: 1; background: #000; display: flex; align-items: center; justify-content: center; overflow: hidden; }
        video { width: 100%; height: 100%; object-fit: contain; }
        canvas#overlay { position: absolute; pointer-events: none; width: 100%; height: 100%; object-fit: contain; }

        /* 交互控制区 */
        #controls { padding: 15px; background: #1e1e1e; border-top: 1px solid #333; }
        
        /* 安全进度条 */
        #timeline-container { position: relative; width: 100%; height: 40px; background: #333; border-radius: 4px; cursor: pointer; margin-bottom: 10px; overflow: hidden; }
        #safety-canvas { width: 100%; height: 100%; }
        #play-head { position: absolute; top: 0; width: 2px; height: 100%; background: #fff; box-shadow: 0 0 5px rgba(0,0,0,0.5); pointer-events: none; }

        .btn-group { display: flex; gap: 10px; align-items: center; }
        input[type="file"] { display: none; }
        .btn { background: #3498db; color: white; padding: 8px 16px; border-radius: 4px; cursor: pointer; font-size: 14px; }
        #status-text { font-size: 12px; color: #aaa; }
    </style>
</head>
<body>

<div id="stage">
    <video id="mainVideo" playsinline></video>
    <canvas id="overlay"></canvas>
</div>

<div id="controls">
    <div id="timeline-container">
        <canvas id="safety-canvas"></canvas>
        <div id="play-head" style="left: 0%"></div>
    </div>
    
    <div class="btn-group">
        <label class="btn" for="fileInput">上传记录仪视频</label>
        <input type="file" id="fileInput" accept="video/*">
        <span id="status-text">等待视频导入...</span>
    </div>
</div>

<script>
    const video = document.getElementById('mainVideo');
    const overlay = document.getElementById('overlay');
    const ctx = overlay.getContext('2d');
    const safetyCanvas = document.getElementById('safety-canvas');
    const sCtx = safetyCanvas.getContext('2d');
    const playHead = document.getElementById('play-head');
    const statusText = document.getElementById('status-text');

    let model = null;
    let safetyData = []; // 存储每秒的风险等级

    // 1. 加载模型
    async function init() {
        statusText.innerText = "模型加载中...";
        model = await cocoSsd.load({ base: 'lite_mobilenet_v2' });
        statusText.innerText = "就绪，请上传视频";
    }

    // 2. 视频处理入口
    document.getElementById('fileInput').onchange = async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        
        video.src = URL.createObjectURL(file);
        statusText.innerText = "正在解析视频结构...";
        
        video.onloadedmetadata = () => {
            overlay.width = video.videoWidth;
            overlay.height = video.videoHeight;
            safetyCanvas.width = safetyCanvas.offsetWidth;
            safetyCanvas.height = safetyCanvas.offsetHeight;
            startAnalysis();
        };
    };

    // 3. 实时分析与渲染循环
    async function startAnalysis() {
        video.play();
        statusText.innerText = "正在实时监控风险...";
        
        function loop() {
            if (video.paused || video.ended) return;
            
            // 更新进度条位置
            const progress = (video.currentTime / video.duration) * 100;
            playHead.style.left = progress + "%";

            // 执行检测
            detectFrame();
            requestAnimationFrame(loop);
        }
        loop();
    }

    async function detectFrame() {
        const predictions = await model.detect(video);
        ctx.clearRect(0, 0, overlay.width, overlay.height);
        
        let minTTC = 99; // 本帧最小TTC

        predictions.forEach(p => {
            if (['car', 'truck', 'bus'].includes(p.class)) {
                const [x, y, w, h] = p.bbox;
                
                // 简化TTC逻辑：根据高度占画面的比例估算
                const distanceFactor = h / overlay.height;
                const currentTTC = 1 / (distanceFactor * 1.5); // 模拟算法
                
                const isCenter = Math.abs((x + w/2) - overlay.width/2) < overlay.width * 0.25;
                if(isCenter && currentTTC < minTTC) minTTC = currentTTC;

                // 绘制轮廓
                ctx.strokeStyle = (isCenter && currentTTC < 3) ? '#ff0000' : '#00ff00';
                ctx.lineWidth = 5;
                ctx.strokeRect(x, y, w, h);
                ctx.fillStyle = ctx.strokeStyle;
                ctx.fillText(`TTC: ${currentTTC.toFixed(1)}s`, x, y - 10);
            }
        });

        // 实时记录数据并绘制安全条
        updateSafetyTimeline(video.currentTime, minTTC);
    }

    // 4. 绘制安全进度条 (热力图)
    function updateSafetyTimeline(time, ttc) {
        const x = (time / video.duration) * safetyCanvas.width;
        sCtx.fillStyle = ttc < 3 ? '#ff4d4d' : '#2ecc71';
        sCtx.fillRect(x, 0, 2, safetyCanvas.height);
    }

    // 5. 进度条点击/移动交互
    const timeline = document.getElementById('timeline-container');
    const handleSeek = (e) => {
        const rect = timeline.getBoundingClientRect();
        const offsetX = (e.clientX || e.touches[0].clientX) - rect.left;
        const percent = Math.min(Math.max(offsetX / rect.width, 0), 1);
        video.currentTime = percent * video.duration;
    };

    timeline.addEventListener('mousedown', (e) => {
        handleSeek(e);
        timeline.addEventListener('mousemove', handleSeek);
    });
    window.addEventListener('mouseup', () => timeline.removeEventListener('mousemove', handleSeek));
    timeline.addEventListener('touchstart', (e) => handleSeek(e));

    init();
</script>
</body>
</html>
