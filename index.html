<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI 驾驶行为深度分析仪</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@latest"></script>
    <style>
        :root { --danger: #ff3333; --safe: #00ff00; }
        body { margin: 0; background: #0a0a0a; color: #fff; font-family: 'PingFang SC', sans-serif; }
        
        #layout { display: flex; flex-direction: column; height: 100vh; }
        #viewer { position: relative; flex: 1; background: #000; overflow: hidden; display: flex; justify-content: center; }
        video { width: 100%; height: 100%; object-fit: contain; }
        canvas#renderCanvas { position: absolute; width: 100%; height: 100%; object-fit: contain; pointer-events: none; }

        #controls { padding: 20px; background: #1a1a1a; border-top: 2px solid #333; }
        
        /* 热力进度条 */
        #timeline-wrapper { position: relative; width: 100%; height: 50px; background: #222; border-radius: 6px; cursor: pointer; margin-bottom: 15px; border: 1px solid #444; }
        #safety-bar { width: 100%; height: 100%; border-radius: 4px; }
        #playhead { position: absolute; top: 0; width: 3px; height: 100%; background: #fff; box-shadow: 0 0 8px #fff; pointer-events: none; transition: left 0.1s linear; }

        .toolbar { display: flex; gap: 15px; align-items: center; }
        .upload-btn { background: #007aff; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-weight: bold; }
        #status { font-size: 13px; color: #888; }
        input[type="file"] { display: none; }
    </style>
</head>
<body>

<div id="layout">
    <div id="viewer">
        <video id="videoSource" playsinline muted></video>
        <canvas id="renderCanvas"></canvas>
    </div>

    <div id="controls">
        <div id="timeline-wrapper">
            <canvas id="safety-bar"></canvas>
            <div id="playhead" style="left: 0%"></div>
        </div>
        
        <div class="toolbar">
            <label class="upload-btn" for="fileInput">导入记录仪素材</label>
            <input type="file" id="fileInput" accept="video/*">
            <div id="status">等待载入模型...</div>
        </div>
    </div>
</div>

<script>
    const video = document.getElementById('videoSource');
    const canvas = document.getElementById('renderCanvas');
    const ctx = canvas.getContext('2d');
    const safetyBar = document.getElementById('safety-bar');
    const sCtx = safetyBar.getContext('2d');
    const status = document.getElementById('status');
    const playhead = document.getElementById('playhead');

    let model = null;
    let hoodY = 0; // 自动检测到的机盖/挡风边界高度
    let analysisMap = new Map(); // 存储已分析帧的结果 {time: {ttc, detections}}

    async function initModel() {
        model = await cocoSsd.load({ base: 'lite_mobilenet_v2' });
        status.innerText = "模型就绪，请上传视频";
    }

    // 1. 自动检测本车边界 (挡风玻璃/机盖线)
    function detectHoodLine() {
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = video.videoWidth;
        tempCanvas.height = video.videoHeight;
        const tCtx = tempCanvas.getContext('2d');
        tCtx.drawImage(video, 0, 0);
        
        // 取画面底部30%进行边缘分析
        const scanStart = Math.floor(video.videoHeight * 0.7);
        const imgData = tCtx.getImageData(0, scanStart, video.videoWidth, video.videoHeight - scanStart);
        
        // 简化的边缘查找：寻找水平连续的高对比度区域
        // 这里默认设定一个经验值，并根据画面进行微调
        hoodY = video.videoHeight * 0.88; 
        console.log("检测到本车基准线高度:", hoodY);
    }

    document.getElementById('fileInput').onchange = async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        
        video.src = URL.createObjectURL(file);
        status.innerText = "预处理中，请稍候...";
        
        video.onloadedmetadata = async () => {
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            safetyBar.width = safetyBar.offsetWidth;
            safetyBar.height = safetyBar.offsetHeight;
            
            detectHoodLine();
            startSmartAnalysis();
        };
    };

    // 2. 预处理逻辑：领先播放进度进行扫描
    async function startSmartAnalysis() {
        video.play();
        
        // 渲染循环
        const renderLoop = () => {
            if (video.ended) return;
            drawFrame();
            requestAnimationFrame(renderLoop);
        };
        renderLoop();

        // 分析逻辑 (尽可能快地跑)
        while(!video.ended) {
            if (video.paused) { await new Promise(r => setTimeout(r, 500)); continue; }
            
            const currentTime = video.currentTime;
            // 如果已经分析到了 6秒 之后，或者已经到结尾，稍作停顿
            if (analysisMap.has(currentTime.toFixed(1))) {
                await new Promise(r => setTimeout(r, 100));
                continue;
            }

            const predictions = await model.detect(video);
            processDetections(currentTime, predictions);
            
            // 实时更新进度条颜色
            updateTimeline();
        }
    }

    function processDetections(time, predictions) {
        let minTTC = 99;
        const processed = predictions.filter(p => ['car', 'truck', 'bus'].includes(p.class)).map(p => {
            const [x, y, w, h] = p.bbox;
            const bottomY = y + h;
            const centerX = x + w/2;
            
            // TTC 计算逻辑
            // 距离基准线的像素距离
            const pixelDist = hoodY - bottomY;
            // 简单的透视估算：基于框体大小和位置变化
            let ttc = pixelDist / (h * 0.5); // 模拟速度向量
            if (ttc < 0) ttc = 99;

            const isCenter = Math.abs(centerX - canvas.width/2) < canvas.width * 0.2;
            if (isCenter && ttc < minTTC) minTTC = ttc;

            return { bbox: p.bbox, ttc, isCenter };
        });

        analysisMap.set(time.toFixed(1), { ttc: minTTC, items: processed });
    }

    // 3. 画面渲染
    function drawFrame() {
        const timeKey = video.currentTime.toFixed(1);
        const data = analysisMap.get(timeKey);
        
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        playhead.style.left = (video.currentTime / video.duration * 100) + "%";

        // 绘制基准线
        ctx.strokeStyle = 'rgba(255,255,255,0.3)';
        ctx.setLineDash([5, 5]);
        ctx.beginPath(); ctx.moveTo(0, hoodY); ctx.lineTo(canvas.width, hoodY); ctx.stroke();
        ctx.setLineDash([]);

        if (!data) return;

        data.items.forEach(item => {
            const [x, y, w, h] = item.bbox;
            const isDanger = item.isCenter && item.ttc < 3;
            
            // 颜色切换
            const color = isDanger ? '#ff3333' : '#00ff00';
            ctx.strokeStyle = color;
            ctx.lineWidth = 4;
            ctx.strokeRect(x, y, w, h);

            // 绘制文字标记
            ctx.fillStyle = color;
            ctx.font = "bold 24px Arial";
            ctx.fillText(`${item.ttc.toFixed(1)}s`, x, y - 10);
        });
    }

    // 4. 更新热力进度条
    function updateTimeline() {
        sCtx.clearRect(0,0, safetyBar.width, safetyBar.height);
        const sortedKeys = Array.from(analysisMap.keys()).sort((a,b) => a-b);
        
        const cellWidth = safetyBar.width / (video.duration * 10); // 0.1秒一格
        
        sortedKeys.forEach(key => {
            const data = analysisMap.get(key);
            const x = (parseFloat(key) / video.duration) * safetyBar.width;
            sCtx.fillStyle = data.ttc < 3 ? '#ff3333' : '#00ff00';
            sCtx.fillRect(x, 0, cellWidth + 1, safetyBar.height);
        });

        // 更新状态文字
        const lastAnalyzed = sortedKeys[sortedKeys.length-1] || 0;
        status.innerText = `已分析至: ${lastAnalyzed}s / 总长: ${video.duration.toFixed(1)}s`;
    }

    // 点击跳转
    document.getElementById('timeline-wrapper').onclick = (e) => {
        const rect = e.currentTarget.getBoundingClientRect();
        const percent = (e.clientX - rect.left) / rect.width;
        video.currentTime = percent * video.duration;
    };

    initModel();
</script>
</body>
</html>
